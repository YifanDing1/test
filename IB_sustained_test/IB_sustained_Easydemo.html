<!DOCTYPE html>

<html>
<head>
    <meta charset=\"utf-8\">
    <title>Multiple Object Tracking</title>
    <style>
        #all {
            width: 700px;
            font-family: "Arial", sans-serif;
            margin: 10px auto 10px auto;
            font-size: 20px;
            text-align: center;
        }
        #objects {
            background-color: #7676A7;
            display: block;
            margin: 0 auto;
        }
        #fixation {
            display: block;
            margin: 0 auto;
            width: 666px;
            height: 546px;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        .svg-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Two columns */
            gap: 10px; /* Space between grid items */
        }
        .svg-box {
            margin: 20px;
            position: relative;
        }
        .svg-box svg {
            width: 80px;
            height: auto;
        }
        fieldset {
            border: 0px;
            font-family: "Arial", sans-serif;
            padding-left: 0px;
            padding-right: 0px;
        }
    </style>
</head>
<body>

<div id="all" style="position: relative; visibility: hidden">
    <form id="task_data" name="task_data" action="data.php" method="post"><fieldset>
        <!--<form id="task_data" onclick=openFullscreen() name="task_data" action="data.php" method="post"><fieldset>-->
        <canvas id="objects" width="666" height="546" style="z-index:1"></canvas>
        <canvas id="fixation" width="666" height="546" style="z-index:2"></canvas>
        <button
                name="myButton" id="myButton"
                style="position:absolute; z-index:3, top:250px; left:320px"
                disabled
                onclick="setTimeout(function() {
                document.getElementById('myButton')
                .setAttribute('disabled', true)})"
        > Continue </button>

        <script>
            let button = document.getElementById('myButton')
            function disable_button() {
                button.removeAttribute('disabled')
            }
        </script>

        <script>
            function checkBothCounts() {
                var circleCount = document.getElementById('count_circle').value;
                var squareCount = document.getElementById('count_square').value;

                if (circleCount && squareCount) {
                    disable_button();
                }
            }
        </script>

        <div>
            <input
                    type="number" id="count" min="0" max="100"
                    placeholder="Enter count"
                    style="position:absolute; z-index:3; top:270px; left:300px; width:99px"
                    oninput="disable_button()">
        </div>

        <div id="input_circle">
            <label for="count_circle" style="position:absolute; z-index:3; top:240px; left:300px; color:white;">Bounces by circles:</label>
            <input
                    type="number" id="count_circle" min="0" max="100"
                    placeholder="Enter count"
                    style="position:absolute; z-index:3; top:270px; left:300px; width:99px"
                    oninput="checkBothCounts()">
        </div>

        <div id="input_square">
            <label for="count_square" style="position:absolute; z-index:3; top:310px; left:300px; color:white;">Bounces by squares:</label>
            <input
                    type="number" id="count_square" min="0" max="100"
                    placeholder="Enter count"
                    style="position:absolute; z-index:3; top:340px; left:300px; width:99px"
                    oninput="checkBothCounts()">
        </div>

        <div id="ibShape" class="svg-container" align='left' style="position:absolute; z-index:3; top:250px; left:200px; color:white">
            <div class="svg-box">
                <input type="radio" name="ibRespShape" value="cross" oninput="disable_button()">
                <svg width="100" height="100" viewBox="0 0 100 100">
                    <line x1="0" y1="50" x2="100" y2="50" style="stroke:#777777; stroke-width:10"/>
                    <line x1="50" y1="0" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                </svg>
            </div>
            <div class="svg-box">
                <input type="radio" name="ibRespShape" value="X" oninput="disable_button()">
                <svg width="100" height="100" viewBox="0 0 100 100">
                    <line x1="10" y1="10" x2="90" y2="90" style="stroke:#777777; stroke-width:10"/>
                    <line x1="90" y1="10" x2="10" y2="90" style="stroke:#777777; stroke-width:10"/>
                </svg>
            </div>
            <div class="svg-box">
                <input type="radio" name="ibRespShape" value="L" oninput="disable_button()">
                <svg width="100" height="100" viewBox="0 0 100 100">
                    <line x1="25" y1="10" x2="25" y2="90" style="stroke:#777777; stroke-width:10"/>
                    <line x1="20" y1="90" x2="75" y2="90" style="stroke:#777777; stroke-width:10"/>
                </svg>
            </div>
            <div class="svg-box">
                <input type="radio" name="ibRespShape" value="T" oninput="disable_button()">
                <svg width="100" height="100" viewBox="0 0 100 100">
                    <line x1="10" y1="20" x2="90" y2="20" style="stroke:#777777; stroke-width:10"/>
                    <line x1="50" y1="20" x2="50" y2="100" style="stroke:#777777; stroke-width:10"/>
                </svg>
            </div>
        </div>
        <div id="ibDirection" align = 'left' style="position:absolute; z-index:3; top:220px; left:290px; color:white">
            <input type="radio" name="ibRespDirection" value="toLeft" oninput="disable_button()">
            <label for="ibRespDirection"> Right to Left </label> <br><br>
            <input type="radio" name="ibRespDirection" value="toRight" oninput="disable_button()">
            <label for="ibRespDirection"> Left to Right </label> <br>

        </div>
        <div id="priorib" align='left' style="position:absolute; z-index:3; top:200px; left:300px; color:white">
            <input type="radio" name="prior" value="No"
                   oninput="disable_button()"
            >
            <label for="prior"> No </label> <br>

            <input type="radio" name="prior" value="Yes"
                   oninput="disable_button()"
            >
            <label for="prior"> Yes </label> <br><br>
            <input type="text" name="prior" id="taskFamiliarDescription" value="" style="height: 25px; width: 200px">
        </div>
        <div id="lookFor" align='left' style="position:absolute; z-index:3; top:200px; left:60px; color:white">
            <input type="radio" name="prior" value="No"
                   oninput="disable_button()"
            >
            <label for="prior"> No, I was focused on judging which line was longer and was not looking for an additional object </label> <br>
            <br><br>
            <input type="radio" name="prior" value="Yes"
                   oninput="disable_button()"
            >
            <label for="prior"> Yes, I was looking for an additional object while also judging which line was longer </label> <br><br>
        </div>
        <div id="YesNo" align='left' style="position:absolute; z-index:3; top:200px; left:300px; color:white">
            <input type="radio" name="prior" value="Yes"
                   oninput="disable_button()"
            >
            <label for="prior"> Yes </label> <br>
            <input type="radio" name="prior" value="No"
                   oninput="disable_button()"
            >
            <label for="prior"> No </label> <br>
        </div>
        <div id="StutterFreeze" align='left' style="position:absolute; z-index:3; top:200px; left:300px; color:white">
            <input type="radio" name="Stuttering" value="Stuttering"
                   oninput="disable_button()"
            >
            <label for="Stuttering"> Stuttering </label> <br>
            <input type="radio" name="Freezing" value="Freezing"
                   oninput="disable_button()"
            >
            <label for="Freezing"> Freezing </label> <br>
            <input type="radio" name="Other" value="Other"
                   oninput="disable_button()"
            >
            <label for="Other"> Other </label> <br>
        </div>
        <div id="norvis" align='left' style="position:absolute; z-index:3; top:170px; left:50px; color:white">
            <input type="radio" name="normal_vision" value="0" oninput="disable_button()">
            <label for="normal_vision"> My vision is normal. I don't need glasses or contacts. </label> <br>
            <input type="radio" name="normal_vision" value="1" oninput="disable_button()">
            <label for="normal_vision"> I need glasses or contacts, and I wore them during the experiment. </label> <br>
            <input type="radio" name="normal_vision" value="2" oninput="disable_button()">
            <label for="normal_vision"> I need glasses or contacts, but I wasn't wearing them during the experiment. </label>
        </div>
        <div id="cboxes" align="left" style="position:absolute; z-index:3; top:200px; left:160px; color:white;">
            <input type="text" name="playback" id="play_text" value="" oninput="disable_button()" style="height: 50px; width: 400px">
        </div>
        <script type="text/javascript">
            // document.getElementById("task_data").onsubmit = function(e) {
            //   window.onbeforeunload = null;
            //   return true;
            // };

            window.onload = function() {
                //Hide all the form bits for now
                document.getElementById("task_submit").style.visibility = 'hidden';
                document.getElementById("count").style.visibility = 'hidden';
                document.getElementById("count_circle").style.visibility = 'hidden';
                document.getElementById("input_circle").style.visibility = 'hidden';
                document.getElementById("count_square").style.visibility = 'hidden';
                document.getElementById("input_square").style.visibility = 'hidden';
                document.getElementById("myButton").style.visibility = 'hidden';
                document.getElementById("ibDirection").style.visibility = 'hidden';
                document.getElementById("ibShape").style.visibility = 'hidden';
                document.getElementById("cboxes").style.visibility = 'hidden';
                document.getElementById("priorib").style.visibility = 'hidden';
                document.getElementById("lookFor").style.visibility = 'hidden';
                document.getElementById("YesNo").style.visibility = 'hidden';
                document.getElementById("StutterFreeze").style.visibility = "hidden";
                document.getElementById("norvis").style.visibility = 'hidden';

                //Define global experiment parameters
                function getCounterFromUrl() {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get('counter'); // Will return null if 'counter' is not in the URL
                }

                // Retrieve the counter value
                const counterValue = getCounterFromUrl();
                console.log("Counter value from URL:", counterValue);

                var isFinalSubmit = false;
                var finalSubmitButton = document.getElementById('task_submit');
                finalSubmitButton.addEventListener('click', function() {
                    isFinalSubmit = true;
                });
                function padTo2Digits(num) {
                    return num.toString().padStart(2, '0');
                }

                function formatDate(date) {
                    return (
                        [
                            date.getUTCFullYear(),
                            padTo2Digits(date.getUTCMonth() + 1),
                            padTo2Digits(date.getUTCDate()),
                        ].join('/') +
                        ' ' +
                        [
                            padTo2Digits(date.getUTCHours()),
                            padTo2Digits(date.getUTCMinutes()),
                            padTo2Digits(date.getUTCSeconds()),
                        ].join(':')
                    );
                }

                var Day = formatDate(new Date()); //The Time saved here is in UTC, which is 5 to 6 hours different from CST.
                console.log(Day);
                var TimeStart = new Date();
                var canvas = document.getElementById('objects');
                var canvasFix = document.getElementById('fixation');
                var context = canvas.getContext('2d');
                var contextFix = canvasFix.getContext('2d');
                var stimWidth = 44;
                var barThickness = Math.round(0.25 * stimWidth);
                var frameTime = 27;  // Duration in ms of each frame. 33 results in FPS of 30.
                var numObjects = 8;  // Number of objects total.  Must be an even number.
                var trialStartTime = 0;
                var waitTime = 1000;
                var trialDur = 19000; // Trial duration
                var ib = false;
                var ibStart = 5000;
                SingleOrDualCounts = 0 //Math.random() < 0.5 ? 0 : 1;

                var trialSequence = ["start", "no_ib", "no_ib", "ib", "shapeIB", "LookForUEO", "divid_attend", "shapeIB", "LookForUEO_post", "playback_pre", "playback_options", "playback", "end"];

                var conditionDict = {
                    0: ["white", "black", "circles", "squares"],
                    1: ["white", "black", "squares", "circles"],
                };

                var demo_data = {
                    counter: counterValue,
                    Day: '',
                    DayEnd: '',
                    glitches: '',
                    glitch_stutterFreeze: '',
                    glitchesDescription: '',
                    normal_vision: '',
                    taskFamiliar: '',
                    taskFamiliarDescription: ''
                };
                demo_data['Day'] = Day;
                console.log('counter', demo_data['counter']);

                function getRadioValue(name, clear) {
                    var group = document.getElementsByName(name);
                    for (var i = 0; i < group.length; i++) {
                        if (group[i].checked) {
                            val = group[i].value;
                            if (clear) {
                                group[i].checked = false;
                            }
                            return val;
                        }
                    }
                    return '';
                }

                function get_condition() {
                    //document.getElementById('task_data').addEventListener('submit', function(event){
                    document.getElementById('task_data').addEventListener('submit', function(event){
                        event.preventDefault();
                        if (!isFinalSubmit) {
                            // If it's not the final submit, do nothing or handle as needed
                            return;
                        }
                        // Reset the flag
                        isFinalSubmit = false;

                        var formData = new FormData(this);
                        var object = {};

                        formData.forEach(function(value, key){
                            console.log(key + ": " + value); // This will log each key-value pair
                            object[key] = value;
                        });
                        console.log("Data being sent:", object);

                        var json = JSON.stringify(object);
                        console.log("JSON being sent:", json);

                        var xhr = new XMLHttpRequest();
                        xhr.open("POST", "data.php", true);
                        xhr.setRequestHeader("Content-Type", "application/json");
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4 && xhr.status === 200) {
                                var response = JSON.parse(xhr.responseText);
                                console.log(response);
                                // Handle response here
                                window.location.href = 'http://localhost/prolific/task_index.html';
                            }
                        };
                        xhr.send(json);
                    });
                }

                var ibshapes = ['cross', 'X', 'L', 'T'];
                function assign_condition() {
                    IB_S_BackgroundRGB = "#7676A7";
                    ibColor = "grey";
                    IB_S_UnexpectedObjectRGB = '#777777';
                    ibShape = ibshapes[Math.floor(Math.random() * ibshapes.length)];

                    rnd = Math.floor(Math.random() * 2)
                    random1 = conditionDict[rnd][0]
                    random2 = conditionDict[rnd][1]
                    random3 = conditionDict[rnd][2]
                    random4 = conditionDict[rnd][3]
                    attendedColor = random1; // attended set name for the instructions
                    attendedShape = random3;
                    unattendedColor = random2; //inverse[attendedColor];
                    unattendedShape = random4;

                    trial_data = {
                        IB_S_SingleOrDualCounts: '',
                        UnexpectedObjectDuration: '10s',
                        attendedColor: attendedColor,
                        ignoredColor: unattendedColor,
                        ibShapeCrit: '',
                        ibDirectionCrit: '',
                        ibShapeVio: '',
                        ibDirectionVio: '',
                        ChoiceArray: '+,X,L,T',
                        Circle_bounces: [],
                        Square_bounces: [],
                        All_bounces: [],
                        circle_counts: [],
                        square_counts: [],
                        All_counts: [],
                        t1_acc: '',
                        t2_acc: '',
                        t3_acc: '',
                        t4_acc: '',
                        t_12_acc: '',
                        t3_notice_ib: '',
                        t4_notice_ib: '',
                        shapeResponse: [],
                        lookingForUEO: '',
                        lookingForUEO_divid: '',

                        trialDuration: trialDur,
                        resp_ib_obj: '',
                        notice_full: '',
                    };

                    nameSingleOrDualCounts();
                    function nameSingleOrDualCounts(){
                        if (SingleOrDualCounts === 1) {
                            trial_data["IB_S_SingleOrDualCounts"] = 'dual'
                        } else {
                            trial_data["IB_S_SingleOrDualCounts"] = 'single'
                        }
                    }
                    console.log("IB_S_SingleOrDualCounts", trial_data["IB_S_SingleOrDualCounts"])
                }

                //This is where we'll push the objects once they're created for easy access.
                var objectArray = []; //window.objectArray

                //A special function to handle the IB response, because this code is a klugey mess
                //and I don't know how to Javascript
                function getIBResponse(event) {
                    event.preventDefault();
                    if (trialType == 'ib') {
                        trial_data["t3_notice_ib"] = getRadioValue("prior", true);
                    } else if (trialType == 'divid_attend') {
                        trial_data["t4_notice_ib"] = getRadioValue("prior", true);
                    }
                    document.getElementById("priorib").style.visibility = 'hidden';
                    document.removeEventListener("submit", getIBResponse, false);
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    document.getElementById("count").style.visibility = 'hidden';
                    document.getElementById("count_circle").style.visibility = 'hidden';
                    document.getElementById("count_square").style.visibility = 'hidden';
                    document.getElementById("myButton").style.visibility = 'hidden';
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    trialType = trialSequence.shift();
                    postTrialQs(trialType)
                }

                //This function saves the subject response after each trial.
                function getResponse(event) {
                    event.preventDefault();
                    document.getElementById("count").style.visibility = 'hidden';
                    document.getElementById("count_circle").style.visibility = 'hidden';
                    document.getElementById("input_circle").style.visibility = 'hidden';
                    document.getElementById("count_square").style.visibility = 'hidden';
                    document.getElementById("input_square").style.visibility = 'hidden';
                    document.getElementById("myButton").style.visibility = 'hidden';
                    if (trialType == 'ib') {
                        if (SingleOrDualCounts === 0) {
                            trial_data["All_counts"].push(document.getElementById("count").value);
                            document.getElementById("count").value = "";
                        } else {
                            var circleCount = parseInt(document.getElementById("count_circle").value, 10);
                            var squareCount = parseInt(document.getElementById("count_square").value, 10);
                            trial_data["circle_counts"].push(circleCount);
                            trial_data["square_counts"].push(squareCount);
                            var totalCount = circleCount + squareCount;
                            trial_data["All_counts"].push(totalCount);
                            document.getElementById("count_circle").value = "";
                            document.getElementById("count_square").value = "";
                        }
                        console.log(trial_data["circle_counts"])
                        console.log(trial_data["square_counts"])
                        console.log(trial_data["All_counts"])
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        ibInst = "Did you notice an additional object during the last counting task that wasn't there " +
                            "on the first two?";
                        document.getElementById("priorib").style.visibility = 'visible';
                        document.getElementById("taskFamiliarDescription").style.visibility = 'hidden';
                        document.getElementById("myButton").style.visibility = 'visible';
                        printAtWordWrap(ibInst, canvas.width / 2, canvas.height / 2 - 150, 30, canvas.width - 50);
                        document.addEventListener("submit", getIBResponse, false);
                    } else if (trialType == "divid_attend") {
                        if (SingleOrDualCounts === 0) {
                            trial_data["All_counts"].push(document.getElementById("count").value);
                            document.getElementById("count").value = "";
                        } else {
                            var circleCount = parseInt(document.getElementById("count_circle").value, 10);
                            var squareCount = parseInt(document.getElementById("count_square").value, 10);
                            trial_data["circle_counts"].push(circleCount);
                            trial_data["square_counts"].push(squareCount);
                            var totalCount = circleCount + squareCount;
                            trial_data["All_counts"].push(totalCount);
                            document.getElementById("count_circle").value = "";
                            document.getElementById("count_square").value = "";
                        }
                        console.log(trial_data["circle_counts"])
                        console.log(trial_data["square_counts"])
                        console.log(trial_data["All_counts"])
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        ibInst = "Did you notice an extra object on that trial?";
                        document.getElementById("priorib").style.visibility = 'visible';
                        document.getElementById("taskFamiliarDescription").style.visibility = 'hidden';
                        document.getElementById("myButton").style.visibility = 'visible';
                        printAtWordWrap(ibInst, canvas.width / 2, canvas.height / 2 - 150, 30, canvas.width - 50);
                        document.addEventListener("submit", getIBResponse, false);
                    } else if (trialType == "shapeIB") {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        //trial_data["shapeResponse"] = getRadioValue("ibRespShape", true);
                        var inShapeResp = getRadioValue("ibRespShape", true);
                        trial_data["shapeResponse"].push(inShapeResp);
                        console.log("shapeResponse", trial_data["shapeResponse"]);
                        document.getElementById("myButton").style.visibility = 'hidden';
                        document.getElementById("ibShape").style.visibility = 'hidden';
                        trialType = trialSequence.shift();
                        postTrialQs(trialType)
                    } else if (trialType == "LookForUEO") {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        trial_data["lookingForUEO"] = getRadioValue("lookFor", true);
                        console.log("lookingForUEO", trial_data["lookingForUEO"]);
                        document.getElementById("myButton").style.visibility = 'hidden';
                        document.getElementById("lookFor").style.visibility = 'hidden';
                        if (SingleOrDualCounts === 0) {
                            instructions = "On the next screen, you will do the same task. Again, please count the total number of times " +
                                "any of the four " + attendedColor.toUpperCase() + " shapes bounce off of the sides of the rectangle. ||" + "Click to begin.";
                        } else {
                            instructions = "On the next screen, you will do the same task. Again, please count, separately, the total number of times any of the two " + attendedColor.toUpperCase() + " circles and squares bounce off of the sides of the rectangle. ||" + "Click to begin.";
                        }
                        displayInstructions(instructions);
                    } else if (trialType == "LookForUEO_post") {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        trial_data["lookingForUEO_divid"] = getRadioValue("lookFor", true);
                        console.log("lookingForUEO_divid", trial_data["lookingForUEO_divid"]);
                        document.getElementById("myButton").style.visibility = 'hidden';
                        document.getElementById("lookFor").style.visibility = 'hidden';
                        trialType = trialSequence.shift();
                        postTrialQs(trialType)
                    } else if (trialType == 'no_ib') {
                        if (SingleOrDualCounts === 0) {
                            trial_data["All_counts"].push(document.getElementById("count").value);
                            document.getElementById("count").value = "";
                            instructions = "On the next screen, you will do the same task. Again, please count the total number of times any of the four " + attendedColor.toUpperCase() + " shapes bounce off of the sides of the rectangle. ||" + "Click to begin.";
                        } else {
                            var circleCount = parseInt(document.getElementById("count_circle").value, 10);
                            var squareCount = parseInt(document.getElementById("count_square").value, 10);
                            trial_data["circle_counts"].push(circleCount);
                            trial_data["square_counts"].push(squareCount);
                            var totalCount = circleCount + squareCount;
                            trial_data["All_counts"].push(totalCount);
                            document.getElementById("count_circle").value = "";
                            document.getElementById("count_square").value = "";
                            instructions = "On the next screen, you will do the same task. Again, please count, separately, the total number of times any of the two " + attendedColor.toUpperCase() + " circles and squares bounce off of the sides of the rectangle. ||" + "Click to begin.";
                        }
                        console.log(trial_data["circle_counts"])
                        console.log(trial_data["square_counts"])
                        console.log(trial_data["All_counts"])
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        displayInstructions(instructions);
                    } else if (trialType == "playback_pre") {
                        demo_data["glitches"] = getRadioValue("prior", true);
                        console.log("glitches", demo_data["glitches"]);
                        skip();
                    } else if (trialType == "playback_options") {
                        demo_data["glitch_stutterFreeze"] = getRadioValue("StutterFreeze", true);
                        console.log("StutterFreeze", demo_data["glitch_stutterFreeze"]);
                        document.getElementById("StutterFreeze").style.visibility = "hidden";
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        contextFix.clearRect(0, 0, canvas.width, canvas.height);
                        trialType = trialSequence.shift();
                        postTrialQs(trialType)
                    } else if (trialType == "playback") {
                        playresp = document.getElementsByName("playback");
                        for (i = 0; i < playresp.length; i++) {
                            if (playresp[i].checked) {
                                demo_data[playresp[i].value] = 1;
                            }
                        }
                        demo_data["glitchesDescription"] = document.getElementById("play_text").value;
                        document.getElementById("cboxes").style.visibility = "hidden";
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        contextFix.clearRect(0, 0, canvas.width, canvas.height);
                        onResponse (trialType == "end");
                    } else if (trialType == "prior") {
                        demo_data["taskFamiliar"] = getRadioValue("prior", true);
                        demo_data["taskFamiliarDescription"] = document.getElementById("taskFamiliarDescription").value;
                        document.getElementById("priorib").style.visibility = "hidden";
                        document.getElementById("taskFamiliarDescription").style.visibility = "hidden";
                        onResponse (trialType == "end");
                    } else if (trialType == "vision") {
                        demo_data["normal_vision"] = getRadioValue("normal_vision", true);
                        document.getElementById("norvis").style.visibility = "hidden";
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        contextFix.clearRect(0, 0, canvas.width, canvas.height);
                        trialType = trialSequence.shift();
                        postTrialQs(trialType)
                    }
                } //end of response function


                //This function specifies the two stimuli types and handles their appearance and movement behavior.
                function Stim(posX, posY, type, color, dX, dY, ux = false, direction) {
                    colorDict = {
                        //blue: '#0066ff', //1st: #0096ff; 2nd: #0066ff 3rd: #003fff
                        background: '#7676A7',
                        black: '#000000',
                        grey: "#777777",
                        white: '#FFFFFF',
                    };
                    this.speedSwitchTime = Date.now() + Math.floor((Math.random() * 1000)) //point at which object's velocity will change, in ms
                    this.type = type;
                    this.ux = ux;
                    this.color = colorDict[color];
                    this.colorName = color;
                    this.thickness = barThickness;
                    this.width = stimWidth;
                    this.boxLeft = this.width / 2;
                    this.boxRight = canvas.width - this.width / 2;
                    this.boxTop = this.width / 2;
                    this.boxBottom = canvas.height - this.width / 2;
                    this.vel = Math.floor((Math.random() * 3) + 2);
                    this.dY = dY;
                    this.dX = dX;
                    this.posX = posX;
                    this.posY = posY;
                    this.bounces = 0;
                    this.bouncesCircle = 0;
                    this.bouncesSquare = 0;
                    //Define movement behavior
                    if (this.ux) {
                        if (direction === 1) {
                            this.dX = -1
                        } else {
                            this.dX = 1
                        }
                        //this.dX = -1; //the circle moves right to left at a constant rate
                        this.vel = 2;
                        this.move = function () {
                            this.posX += this.vel * this.dX;
                        }
                    } else {
                        this.move = function () {
                            //This suite checks to see if the object has collided with the
                            //boundary walls, resets the position to inside the walls, and
                            //changes the movement direction
                            var bounced = false;
                            if (this.posX > this.boxRight) {
                                this.posX = this.boxRight;
                                this.dX *= -1;
                                this.bounces += 1;
                                bounced = true;
                            }
                            if (this.posX < this.boxLeft) {
                                this.posX = this.boxLeft;
                                this.dX *= -1;
                                this.bounces += 1;
                                bounced = true;
                            }
                            if (this.posY > this.boxBottom) {
                                this.posY = this.boxBottom;
                                this.dY *= -1;
                                this.bounces += 1;
                                bounced = true;
                            }
                            if (this.posY < this.boxTop) {
                                this.posY = this.boxTop;
                                this.dY *= -1;
                                this.bounces += 1;
                                bounced = true;
                            }
                            if (bounced) {
                                if (this.type === "circles") {
                                    this.bouncesCircle += 1;
                                } else if (this.type === "squares") {
                                    this.bouncesSquare += 1;
                                }
                            }
                            //Checks to see if it's time to switch the velocity of the object
                            if (Date.now() >= this.speedSwitchTime) {
                                //If so, pick the next switch time and pick a new velocity
                                this.speedSwitchTime = Date.now() + Math.floor((Math.random() * 800));
                                this.vel = Math.floor((Math.random() * 1.5) + 2);
                                //This clause checks to see whether the object is inside the bounds
                                //of the box, and then randomly decides whether to change the
                                //vertical velocity, horizontal velocity, or both.
                                if ((this.posY > this.boxBottom) && (this.posY < this.boxTop) &&
                                    (this.posX > this.boxLeft) && (this.posX < this.boxRight)) {
                                    this.dX *= [-1, 1][Math.floor((Math.random() * 2))]
                                    this.dY *= [-1, 1][Math.floor((Math.random() * 2))]
                                }
                            }
                            //Update position according to the velocity and movent direction
                            this.posX += this.vel * this.dX;
                            this.posY += this.vel * this.dY;
                        } // end of move function
                    }
                    if (this.type == "circles") {
                        this.draw = function () {
                            context.save();
                            context.beginPath();
                            context.arc(this.posX, this.posY, this.width / 2, 0, 2 * Math.PI, false);
                            context.fillStyle = this.color;
                            context.fill();
                            context.lineWidth = barThickness;
                            context.strokeStyle = this.color;
                            context.stroke();
                            context.restore();
                        }

                    }
                    else if (this.type == "squares") {
                        this.draw = function() {
                            context.save();
                            context.fillStyle = this.color;
                            context.fillRect(this.posX - this.width / 2, this.posY - this.width / 2, this.width, this.width);
                            context.restore();
                        }
                    }
                    else if (this.type == "cross") {
                        this.draw = function() {
                            context.save();
                            context.beginPath();
                            context.strokeStyle = this.color;
                            context.lineWidth = this.width / 4;
                            // Draw horizontal line
                            context.moveTo(this.posX - this.width / 2, this.posY);
                            context.lineTo(this.posX + this.width / 2, this.posY);
                            // Draw vertical line
                            context.moveTo(this.posX, this.posY - this.width / 2);
                            context.lineTo(this.posX, this.posY + this.width / 2);
                            context.stroke();
                            context.restore();
                        }
                    }
                    else if (this.type == "X") {
                        this.draw = function() {
                            context.save();
                            context.beginPath();
                            context.strokeStyle = this.color;
                            context.lineWidth = this.width / 4;
                            // Draw first line of X
                            context.moveTo(this.posX - this.width / 2, this.posY - this.width / 2);
                            context.lineTo(this.posX + this.width / 2, this.posY + this.width / 2);
                            // Draw second line of X
                            context.moveTo(this.posX + this.width / 2, this.posY - this.width / 2);
                            context.lineTo(this.posX - this.width / 2, this.posY + this.width / 2);
                            context.stroke();
                            context.restore();
                        }
                    }
                    else if (this.type == "L") {
                        this.draw = function() {
                            context.save();
                            context.beginPath();
                            context.strokeStyle = this.color;
                            context.lineWidth = this.width / 4;
                            // Draw vertical line for the L
                            context.moveTo(this.posX - this.width / 2, this.posY - this.width / 2.5);
                            context.lineTo(this.posX - this.width / 2, this.posY + this.width / 2.5);
                            // Draw horizontal line for the bottom of the L
                            context.moveTo(this.posX - this.width / 1.6, this.posY + this.width / 2.5);
                            context.lineTo(this.posX, this.posY + this.width / 2.5);
                            context.stroke();
                        }
                    }
                    else if (this.type == "T") {
                        this.draw = function() {
                            context.save();
                            context.beginPath();
                            context.strokeStyle = this.color;
                            context.lineWidth = this.width / 4;
                            // Draw horizontal line for the top of the T
                            context.moveTo(this.posX - this.width / 2.5, this.posY - this.width / 2);
                            context.lineTo(this.posX + this.width / 2.5, this.posY - this.width / 2);
                            // Draw a longer vertical line for the T
                            context.moveTo(this.posX, this.posY - this.width / 2);
                            context.lineTo(this.posX, this.posY + this.width / 3); // Adjust the Y endpoint to be less negative
                            context.stroke();
                            context.restore();
                        }
                    }
                    objectArray.push(this);
                }

                // end of class Stim

                // This function initializes the stimuli (half checkerboards, half squares) to
                // a random position in the box with random directional velocities.
                //var level = 0
                function createAndPlaceObjects(numObjects) {
                    console.log('-----creating--------')
                    objectArray = []
                    //var shapes = ['circles', 'squares', 'circles', 'squares'];
                    //shapes = shuffle(shapes);
                    var attend_color = random1
                    var attend_shape = random3
                    var ignore_color = random2
                    var ignore_shape = random4
                    var colors = [attend_color, attend_color, ignore_color, ignore_color, attend_color, attend_color, ignore_color, ignore_color];
                    var shapes = [attend_shape, attend_shape, attend_shape, attend_shape, ignore_shape, ignore_shape, ignore_shape, ignore_shape];
                    console.log('attend_color:', attend_color)
                    console.log('ignore_color:', ignore_color)
                    console.log('attend_shape:', attend_shape)
                    console.log('ignore_shape:', ignore_shape)
                    //level += 1


                    for (i = 0; i < numObjects; i++) {
                        //var shape = shapes[i % 4];
                        x = Math.floor((Math.random() * (canvas.width - stimWidth / 2)))
                        y = Math.floor((Math.random() * (canvas.height - stimWidth / 2)))
                        xDir = [-1, 1][Math.floor((Math.random() * 2))]
                        yDir = [-1, 1][Math.floor((Math.random() * 2))]
                        //window[shape + colors[i]] = new Stim(x, y, shape, colors[i], xDir, yDir);
                        window[shapes[i] + colors[i]] = new Stim(x, y, shapes[i], colors[i], xDir, yDir);
                    }
                } // end of create and place function

                // Thanks to StackOverflow user Gaby Petrioli for this function
                // This function takes in a multiline string and handles writing
                // it to the canvas.
                function printAtWordWrap(text, x, y, lineHeight, fitWidth) {
                    fitWidth = fitWidth || 0;
                    if (fitWidth <= 0) {
                        context.fillText(text, x, y);
                        return;
                    }
                    var paragraphs = text.split('||');
                    var currentY = y;

                    paragraphs.forEach(function(paragraph) {
                        var words = paragraph.trim().split(' ');
                        var currentLine = 0;
                        var idx = 1;
                        while (words.length > 0 && idx <= words.length) {
                            var str = words.slice(0, idx).join(' ');
                            var w = context.measureText(str).width;
                            if (w > fitWidth) {
                                if (idx == 1) {
                                    idx = 2;
                                }
                                context.fillText(words.slice(0, idx - 1).join(' '), x, currentY + (lineHeight * currentLine));
                                currentLine++;
                                words = words.splice(idx - 1);
                                idx = 1;
                            } else {
                                idx++;
                            }
                        }
                        if (idx > 0) {
                            context.fillText(words.join(' '), x, currentY + (lineHeight * currentLine));
                        }
                        currentY += lineHeight * (currentLine + 2); // Add extra space between paragraphs
                    });
                }

                //Set up the animation callback
                window.requestAnimationFrame = function (callback) {
                    return window.setTimeout(callback, frameTime);
                }
                window.cancelAnimationFrame = window.clearTimeout;

                let lastTime = 0;
                let elapsed = 0;
                let stopAnimation = false;

                function updateAnimation(elapsed) {
                    // Update the animation state based on the elapsed time
                    currTime = new Date();
                    trialTime = currTime - trialStartTime;

                    if ((trialType == "ib" || trialType == "divid_attend") && (trialTime >= ibStart)) {
                        unexObj.move(elapsed);
                    }

                    objectArray.forEach(function (element) {
                        if (!element.ux) {
                            element.move(elapsed);
                        }
                    });
                }

                function renderAnimation() {
                    // Render the animation objects
                    if ((trialType == "ib" || trialType == "divid_attend") && (trialTime >= ibStart)) {
                        unexObj.draw();
                    }

                    objectArray.forEach(function (element) {
                        if (!element.ux) {
                            element.draw();
                        }
                    });
                }

                function runAnimLoop(timestamp) {
                    if (stopAnimation) {
                        // Animation has been stopped, so return without requesting the next frame
                        return;
                    }
                    // Calculate the elapsed time since the last frame
                    elapsed = timestamp - lastTime;
                    lastTime = timestamp;

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    //fix.draw();

                    // Update the animation based on the elapsed time
                    updateAnimation(elapsed);

                    // Render the animation
                    renderAnimation();

                    // Request the next animation frame
                    requestAnimationFrame(runAnimLoop);
                } //end of animation loop function

                var lastDirection = 1;
                var lastShape = null;
                function singleTrial(trialType) {
                    //fix = new Fixation(canvasFix.width / 2, canvasFix.height / 2 - 10, barThickness);
                    if (trialType == 'ib') {
                        var direction = Math.random() < 0.5 ? -1 : 1;
                        trial_data["ibDirectionCrit"] = direction;
                        trial_data["ibShapeCrit"] = ibShape;
                        lastDirection = direction;
                        var startX = direction === -1 ? -30 : canvas.width + 30;
                        console.log('startX:', startX)
                        console.log('direction:', direction)
                        console.log('ibShape:', ibShape)
                        unexObj = new Stim(startX, canvas.height / 2, ibShape, ibColor, -1, 0, ux = true, direction);
                    } else if (trialType == 'divid_attend') {
                        var direction = lastDirection;
                        var startX = direction === -1 ? -30 : canvas.width + 30;
                        console.log('startX:', startX)
                        console.log('direction:', direction)
                        console.log('ibShape:', ibShape)
                        unexObj = new Stim(startX, canvas.height / 2, ibShape, ibColor, -1, 0, ux = true, direction);
                    }
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    lastShape = ibShape;
                    //fix.draw()
                    objectArray.forEach(function (element) {
                        element.draw()
                    });

                    //Pause before starting the animation
                    // setTimeout(function () {
                    //     trialStartTime = Date.now();
                    //     runAnimLoop(ib);
                    // }, waitTime);

                    setTimeout(function () {
                        stopAnimation = false;
                        trialStartTime = Date.now();
                        requestAnimationFrame(runAnimLoop);
                    }, waitTime);

                    //Let the animation run, then handle response capture
                    setTimeout(function () {
                        // window.cancelAnimationFrame(anim);
                        stopAnimation = true;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        contextFix.clearRect(0, 0, canvas.width, canvas.height);
                        var trial_bounces = 0;
                        var trial_bounces_circles = 0;
                        var trial_bounces_squares = 0;
                        console.log("SingleOrDualCounts:", SingleOrDualCounts);
                        objectArray.forEach(function(object) {
                            if (object.colorName === attendedColor) {
                                trial_bounces_circles += object.bouncesCircle;
                                trial_bounces_squares += object.bouncesSquare;
                                trial_bounces += object.bounces;
                                object.bouncesCircle = 0;
                                object.bouncesSquare = 0;
                                object.bounces = 0;
                            }
                        });

                        if (trialType != 'full_attend' && SingleOrDualCounts === 0) {
                            trial_data["All_bounces"].push(trial_bounces);
                            console.log('All_bounces', trial_data["All_bounces"])
                            printAtWordWrap("In the box below, please enter the total number of times the four " + attendedColor.toUpperCase() + " shapes bounced off the edges of the blue rectangle.", canvas.width / 2,
                                canvas.height / 2 - 150, 30, canvas.width - 50);
                            document.addEventListener("submit", getResponse, false);
                            document.getElementById("count").style.visibility = 'visible';
                            document.getElementById("myButton").style.visibility = 'visible';
                        } else if (trialType != 'full_attend' && SingleOrDualCounts === 1) {
                            trial_data["All_bounces"].push(trial_bounces)
                            trial_data["Circle_bounces"].push(trial_bounces_circles);
                            trial_data["Square_bounces"].push(trial_bounces_squares);
                            console.log("Circle Bounces:", trial_data["Circle_bounces"]);
                            console.log("Square Bounces:", trial_data["Square_bounces"]);
                            console.log('All_bounces', trial_data["All_bounces"])
                            printAtWordWrap("In the box below, please enter the total number of times the two " + attendedColor.toUpperCase() +
                                " circles and squares (in each box below) bounced off the edges of the blue rectangle.", canvas.width / 2,
                                canvas.height / 2 - 150, 30, canvas.width - 50);
                            document.addEventListener("submit", getResponse, false);
                            document.getElementById("count_circle").style.visibility = 'visible';
                            document.getElementById("input_circle").style.visibility = 'visible';
                            document.getElementById("count_square").style.visibility = 'visible';
                            document.getElementById("input_square").style.visibility = 'visible';
                            document.getElementById("myButton").style.visibility = 'visible';
                        } else {
                            fullinst = "Did you notice an extra object on that trial?";
                            printAtWordWrap(fullinst, canvas.width / 2,
                                canvas.height / 2 - 150, 30, canvas.width - 50);
                            document.addEventListener("submit", getIBResponse, false);
                            document.getElementById("priorib").style.visibility = 'visible';
                            document.getElementById("taskFamiliarDescription").style.visibility = 'hidden';
                            document.getElementById("myButton").style.visibility = 'visible';
                        }
                        //Set up the input event listeners and direct both to the same function
                    }, trialDur);
                } //end of single trial function

                function calculate() {
                    let bounces_t1 = trial_data.All_bounces[0]
                    let bounces_t2 = trial_data.All_bounces[1]
                    let bounces_t3 = trial_data.All_bounces[2]
                    let bounces_t4 = trial_data.All_bounces[3]
                    let count_t1 = parseInt(trial_data.All_counts[0])
                    let count_t2 = parseInt(trial_data.All_counts[1])
                    let count_t3 = parseInt(trial_data.All_counts[2])
                    let count_t4 = parseInt(trial_data.All_counts[4])
                    function validateAccuracy(accuracy) {
                        if (accuracy > 100 || accuracy < 0) {
                            return "N/A";
                        } else {
                            return parseFloat(accuracy.toFixed(2));
                        }
                    }
                    let percent_t1 = ((Math.abs(count_t1 - bounces_t1)/bounces_t1))*100;
                    let percent_t2 = ((Math.abs(count_t2 - bounces_t2)/bounces_t2))*100;
                    let percent_t3 = ((Math.abs(count_t3 - bounces_t3)/bounces_t3))*100;
                    let percent_t4 = ((Math.abs(count_t4 - bounces_t4)/bounces_t4))*100;
                    let percent_t12 = (percent_t1 + percent_t2)/2;
                    let t1_acc = validateAccuracy(100 - percent_t1);
                    let t2_acc = validateAccuracy(100 - percent_t2);
                    let t3_acc = validateAccuracy(100 - percent_t3);
                    let t4_acc = validateAccuracy(100 - percent_t4);
                    let t_12_acc = validateAccuracy(100 - percent_t12);
                    trial_data["t1_acc"] = t1_acc;
                    trial_data["t2_acc"] = t2_acc;
                    trial_data["t3_acc"] = t3_acc;
                    trial_data["t4_acc"] = t4_acc;
                    trial_data["t_12_acc"] = t_12_acc;
                }

                function postTrialQs(info) {
                    posx = canvas.width / 2;
                    posy = canvas.height / 2 - 150;
                    if (info == "playback_pre") {
                        calculate();
                        instr = "Did the animation play smoothly, with no obvious lagging or freezing?";
                        document.getElementById("YesNo").style.visibility = 'visible';
                    } else if (info == "playback_options") {
                        instr = "Was there any stuttering or freezing?";
                        document.getElementById("StutterFreeze").style.visibility = 'visible';
                    } else if (info == "playback") {
                        instr = "Please describe the playback issues you experienced.";
                        document.getElementById("cboxes").style.visibility = 'visible';
                    } else if (info == "prior") {
                        instr = "Have you performed a similar task before, where you were asked to keep track of " +
                            "many moving shapes, and something unexpected appeared? If you have, please briefly " +
                            "describe it in the text box. Your answer will not affect " +
                            "your compensation for completing this study."
                        posy = canvas.height / 2 - 200;
                        document.getElementById("priorib").style.visibility = 'visible';
                        document.getElementById("taskFamiliarDescription").style.visibility = 'visible';
                    } else if (info == "vision") {
                        //printAtWordWrap("Please describe your color vision.", canvas.width / 2,
                        //    canvas.height / 2 + 80, 30, canvas.width - 50)
                        instr = "Please describe your vision."
                        document.getElementById("norvis").style.visibility = 'visible';
                        //document.getElementById("norcol").style.visibility = 'visible';
                    } else if (info == "shapeIB") {
                        instr = "There actually was an extra object. If you saw it, please select the object you saw. If you didn't see it, please guess.";
                        document.getElementById("ibShape").style.visibility = 'visible';
                    } else if (info == "directionIB") {
                        instr = "What was the shape of the extra object? If you didn't see it, please guess.";
                        document.getElementById("ibDirection").style.visibility = 'visible';
                    } else if (info == "LookForUEO" || info == "LookForUEO_post") {
                        instr = "When you were completing that last trial, were you devoting some of your attention to looking for an additional object?";
                        document.getElementById("lookFor").style.visibility = 'visible';
                    }
                    printAtWordWrap(instr, posx, posy, 30, canvas.width - 50);
                    document.addEventListener("submit", getResponse, false);
                    document.getElementById("myButton").style.visibility = 'visible';
                }

                skip = function () {
                    if (demo_data["glitches"] == 'No') {
                        document.getElementById("YesNo").style.visibility = 'hidden';
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        contextFix.clearRect(0, 0, canvas.width, canvas.height);
                        trialType = trialSequence.shift();
                        postTrialQs(trialType)
                    } else if (demo_data["glitches"] == 'Yes') {
                        document.getElementById("YesNo").style.visibility = 'hidden';
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        trialType = trialSequence.shift();
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        trialType = trialSequence.shift();
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        contextFix.clearRect(0, 0, canvas.width, canvas.height);
                        onResponse (trialType == "end");
                    }
                }

                displayInstructions = function (instructions) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    context.textAlign = "center";
                    context.font = "20px Arial";
                    context.fillStyle = "#FFFFFF";
                    printAtWordWrap(instructions, canvas.width / 2,
                        canvas.height / 2 - 150, 30, canvas.width - 50)
                    document.addEventListener("click", onResponse, false)
                }

                displayInstructions2 = function (instructions) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    context.textAlign = "center";
                    context.font = "20px Arial";
                    context.fillStyle = "#FFFFFF";
                    printAtWordWrap(instructions, canvas.width / 2,
                        canvas.height / 2 - 200, 25, canvas.width - 50)
                }

                //This takes the response from the "click to continue" screens and
                //advances to the next trial.
                trialType = "start"; //"pre"
                onResponse = function () {
                    document.removeEventListener("click", onResponse, false)
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    trialType = trialSequence.shift();
                    if (trialType == "pre") {
                        inst = "In this task, 4 white shapes and 4 black shapes will appear inside this colored rectangle. After a moment, they will begin moving and bouncing off the sides of the rectangle. ||" + "Click anywhere to continue."
                        displayInstructions(inst)
                    } else if (trialType == 'start') {
                        if (SingleOrDualCounts === 1) {
                            inst = "Please count the total number of times any of the two " + attendedColor.toUpperCase() + " circles and any of the two "
                                + attendedColor.toUpperCase() + " squares bounce off of the sides of the blue rectangle. Do not count bounces by the " + unattendedColor + " shapes. You will be asked to report your total count for both shapes separately. ||" +
                                "Click anywhere to begin.";
                        } else {
                            inst = "Please count the total number of times any of the four " + attendedColor.toUpperCase() + " shapes bounce off of the sides of the blue rectangle. Do not count bounces by the " +
                                unattendedColor + " shapes. You will be asked to report your total count. ||" +
                                "Click anywhere to begin.";
                        }
                        displayInstructions(inst)
                    } else if (trialType == "draw1") {
                        inst = "The total counts you reported were off by " + percent + "% from the actual counts, on average. " +
                            "Anyone whose average accuracy was within 50% of the correct counts will be entered into the drawing for " +
                            "a bonus payment. Anyone whose average counting accuracy was within 15% of the correct counts will receive two " +
                            "entries in the drawing. Click to continue."
                        displayInstructions(inst)
                    } else if (trialType == "playback_pre" || trialType == "playback_options" || trialType == "playback" || trialType == "LookForUEO" || trialType == "LookForUEO_post" || trialType == "shapeIB") {
                        postTrialQs(trialType)
                    } else if (trialType != 'end') {
                        createAndPlaceObjects(numObjects)
                        singleTrial(trialType)
                    } else {
                        end()
                    }
                }


                function main() {
                    document.getElementById("all").style.visibility = "visible";
                    assign_condition();
                    get_condition();
                    document.getElementById("count").style.visibility = 'hidden';
                    document.getElementById("myButton").style.visibility = 'hidden';
                    var initial_instructions = "In this task, 4 white shapes and 4 black shapes will appear inside this colored rectangle. After a moment, they will begin moving and bouncing off the sides of the rectangle. ||" + "Click anywhere to continue."

                    //console.log(initial_instructions);
                    //createAndPlaceObjects(numObjects);
                    displayInstructions(initial_instructions)
                } // end of main

                //function linebreak() {

                //This function clears out hte display, writes the trial matrix to the hidden form, and
                //passes the data to the PHP file to be written to the database.
                function end() {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    contextFix.clearRect(0, 0, canvas.width, canvas.height);
                    context.fillText("Thank you for completing the task!", canvas.width / 2,
                        canvas.height / 2);
                    var debrief = "Click 'Continue' to proceed."
                    displayInstructions2(debrief);
                    // context.fillText("Please click on the button below to continue.", canvas.width / 2,
                    //     canvas.height / 2 + 250);
                    DayEnd = formatDate(new Date());
                    demo_data["DayEnd"] = DayEnd;
                    var TimeEnd = new Date();
                    duration = Math.round((TimeEnd.getTime() - TimeStart.getTime())/1000);
                    console.log(duration);

                    document.task_data.counter.value = demo_data["counter"];
                    document.task_data.IB_S_start.value = demo_data["Day"];
                    document.task_data.IB_S_end.value = demo_data["DayEnd"];
                    document.task_data.IB_S_duration.value = duration;
                    document.task_data.IB_S_UnexpectedObjectRGB.value = IB_S_UnexpectedObjectRGB;
                    document.task_data.IB_S_BackgroundRGB.value = IB_S_BackgroundRGB;
                    document.task_data.IB_S_UnexpectedObjectDuration.value = trial_data["UnexpectedObjectDuration"];
                    document.task_data.IB_S_SingleOrDualCounts.value = trial_data["IB_S_SingleOrDualCounts"];
                    document.task_data.IB_S_AttendedColor.value = trial_data["attendedColor"];
                    document.task_data.IB_S_IgnoredColor.value = trial_data["ignoredColor"];
                    document.task_data.IB_S_UnexpectedObjectCrit.value = trial_data["ibShapeCrit"];
                    document.task_data.IB_S_UnexpectedObjectDirectionCrit.value = trial_data["ibDirectionCrit"];
                    document.task_data.IB_S_UnexpectedObjectViolation.value = trial_data["ibShapeVio"];
                    document.task_data.IB_S_UnexpectedObjectDirectionViolation.value = trial_data["ibDirectionVio"];
                    document.task_data.IB_S_ChoiceArray.value = trial_data["ChoiceArray"];
                    document.task_data.IB_S_1_bouncesCircles.value = trial_data["Circle_bounces"][0];
                    document.task_data.IB_S_2_bouncesCircles.value = trial_data["Circle_bounces"][1];
                    document.task_data.IB_S_3_bouncesCircles.value = trial_data["Circle_bounces"][2];
                    document.task_data.IB_S_4_bouncesCircles.value = trial_data["Circle_bounces"][3];
                    document.task_data.IB_S_1_bouncesSquares.value = trial_data["Square_bounces"][0];
                    document.task_data.IB_S_2_bouncesSquares.value = trial_data["Square_bounces"][1];
                    document.task_data.IB_S_3_bouncesSquares.value = trial_data["Square_bounces"][2];
                    document.task_data.IB_S_4_bouncesSquares.value = trial_data["Square_bounces"][3];
                    document.task_data.IB_S_1_bouncesAll.value = trial_data["All_bounces"][0];
                    document.task_data.IB_S_2_bouncesAll.value = trial_data["All_bounces"][1];
                    document.task_data.IB_S_3_bouncesAll.value = trial_data["All_bounces"][2];
                    document.task_data.IB_S_4_bouncesAll.value = trial_data["All_bounces"][3];
                    document.task_data.IB_S_1_countCircles.value = trial_data["circle_counts"][0];
                    document.task_data.IB_S_2_countCircles.value = trial_data["circle_counts"][1];
                    document.task_data.IB_S_3_countCircles.value = trial_data["circle_counts"][2];
                    document.task_data.IB_S_4_countCircles.value = trial_data["circle_counts"][4];
                    document.task_data.IB_S_1_countSquares.value = trial_data["square_counts"][0];
                    document.task_data.IB_S_2_countSquares.value = trial_data["square_counts"][1];
                    document.task_data.IB_S_3_countSquares.value = trial_data["square_counts"][2];
                    document.task_data.IB_S_4_countSquares.value = trial_data["square_counts"][4];
                    document.task_data.IB_S_1_countAll.value = trial_data["All_counts"][0];
                    document.task_data.IB_S_2_countAll.value = trial_data["All_counts"][1];
                    document.task_data.IB_S_3_countAll.value = trial_data["All_counts"][2];
                    document.task_data.IB_S_4_countAll.value = trial_data["All_counts"][4];
                    document.task_data.IB_S_1_accuracyAll.value = trial_data["t1_acc"];
                    document.task_data.IB_S_2_accuracyAll.value = trial_data["t2_acc"];
                    document.task_data.IB_S_3_accuracyAll.value = trial_data["t3_acc"];
                    document.task_data.IB_S_4_accuracyAll.value = trial_data["t4_acc"];
                    document.task_data.IB_S_preCritical_accuracyAll.value = trial_data["t_12_acc"];
                    document.task_data.IB_S_3_noticeCritical.value = trial_data["t3_notice_ib"];
                    document.task_data.IB_S_3_choiceCritical.value = trial_data["shapeResponse"][0];
                    document.task_data.IB_S_3_lookingForUnexpectedObjectCritical.value = trial_data["lookingForUEO"];
                    document.task_data.IB_S_4_noticeDivided1.value = trial_data["t4_notice_ib"];
                    document.task_data.IB_S_4_choiceDivided1.value = trial_data["shapeResponse"][1];
                    document.task_data.IB_S_4_lookingForUnexpectedObjectCritical.value = trial_data["lookingForUEO_divid"];
                    document.task_data.IB_S_glitches.value = demo_data["glitches"];
                    document.task_data.IB_S_glitch_stutterFreeze.value = demo_data["glitch_stutterFreeze"];
                    document.task_data.IB_S_glitchesDescription.value = demo_data["glitchesDescription"];
                    document.task_data.IB_S_taskFamiliar.value = demo_data["taskFamiliar"];
                    document.task_data.IB_S_taskFamiliarDescription.value = demo_data["taskFamiliarDescription"];
                    document.removeEventListener("submit", getResponse, false);
                    document.removeEventListener("click", onResponse, false)
                    document.getElementById("task_submit").style.visibility = 'visible';
                    //document.getElementById("task_submit").addEventListener("submit");
                } //end of end (har har)
                main()
            } // end of onload function
        </script>
        <input type="hidden" name="counter" value="">
        <input type="hidden" name="IB_S_start" value="">
        <input type="hidden" name="IB_S_end" value="">
        <input type="hidden" name="IB_S_duration" value="">
        <input type="hidden" name="IB_S_UnexpectedObjectRGB" value="">
        <input type="hidden" name="IB_S_BackgroundRGB" value="">
        <input type="hidden" name="IB_S_UnexpectedObjectDuration" value="">
        <input type="hidden" name="IB_S_SingleOrDualCounts" value="">
        <input type="hidden" name="IB_S_AttendedColor" value="">
        <input type="hidden" name="IB_S_IgnoredColor" value="">
        <input type="hidden" name="IB_S_UnexpectedObjectCrit" value="">
        <input type="hidden" name="IB_S_UnexpectedObjectDirectionCrit" value="">
        <input type="hidden" name="IB_S_UnexpectedObjectViolation" value="">
        <input type="hidden" name="IB_S_UnexpectedObjectDirectionViolation" value="">
        <input type="hidden" name="IB_S_ChoiceArray" value="">
        <input type="hidden" name="IB_S_1_bouncesCircles" value="">
        <input type="hidden" name="IB_S_2_bouncesCircles" value="">
        <input type="hidden" name="IB_S_3_bouncesCircles" value="">
        <input type="hidden" name="IB_S_4_bouncesCircles" value="">
        <input type="hidden" name="IB_S_1_bouncesSquares" value="">
        <input type="hidden" name="IB_S_2_bouncesSquares" value="">
        <input type="hidden" name="IB_S_3_bouncesSquares" value="">
        <input type="hidden" name="IB_S_4_bouncesSquares" value="">
        <input type="hidden" name="IB_S_1_bouncesAll" value="">
        <input type="hidden" name="IB_S_2_bouncesAll" value="">
        <input type="hidden" name="IB_S_3_bouncesAll" value="">
        <input type="hidden" name="IB_S_4_bouncesAll" value="">
        <input type="hidden" name="IB_S_1_countCircles" value="">
        <input type="hidden" name="IB_S_2_countCircles" value="">
        <input type="hidden" name="IB_S_3_countCircles" value="">
        <input type="hidden" name="IB_S_4_countCircles" value="">
        <input type="hidden" name="IB_S_1_countSquares" value="">
        <input type="hidden" name="IB_S_2_countSquares" value="">
        <input type="hidden" name="IB_S_3_countSquares" value="">
        <input type="hidden" name="IB_S_4_countSquares" value="">
        <input type="hidden" name="IB_S_1_countAll" value="">
        <input type="hidden" name="IB_S_2_countAll" value="">
        <input type="hidden" name="IB_S_3_countAll" value="">
        <input type="hidden" name="IB_S_4_countAll" value="">
        <input type="hidden" name="IB_S_1_accuracyAll" value="">
        <input type="hidden" name="IB_S_2_accuracyAll" value="">
        <input type="hidden" name="IB_S_3_accuracyAll" value="">
        <input type="hidden" name="IB_S_4_accuracyAll" value="">
        <input type="hidden" name="IB_S_preCritical_accuracyAll" value="">
        <input type="hidden" name="IB_S_3_noticeCritical" value="">
        <input type="hidden" name="IB_S_3_choiceCritical" value="">
        <input type="hidden" name="IB_S_3_lookingForUnexpectedObjectCritical" value="">
        <input type="hidden" name="IB_S_4_noticeDivided1" value="">
        <input type="hidden" name="IB_S_4_choiceDivided1" value="">
        <input type="hidden" name="IB_S_4_lookingForUnexpectedObjectCritical" value="">
        <input type="hidden" name="IB_S_glitches" value="">
        <input type="hidden" name="IB_S_glitch_stutterFreeze" value="">
        <input type="hidden" name="IB_S_glitchesDescription" value="">
        <input type="hidden" name="IB_S_taskFamiliar" value="">
        <input type="hidden" name="IB_S_taskFamiliarDescription" value="">
        <button type="submit" id="task_submit">Continue</button>
        <!--        <input type="submit" id="task_submit" name="task_submit" value="Finish">-->
    </fieldset>
    </form>
</div>
</body>
</html>